---
title: CSS 的第二个重点之视觉格式化模型
description: 视觉格式化模型
sidebar:
    order: 1
---

之前介绍的 CSS 属性值的计算是 CSS 的第一个重点，另外一个就是本文的主题——视觉格式化模型（Visual Formatting Model）。

## 什么是视觉格式化模型？

---

盒子模型规定了单个盒子的规则，而视觉格式化模型则规定了如何将这些盒子放置在页面上。视觉格式化模型，你也可以将其理解为布局规则：视觉格式化模型大体将页面中盒子的排列分为了三种方式：常规流、浮动和绝对定位。

## 常规流布局

---

**常规流**，也可以叫做**文档流**、**普通文档流**或者**常规文档流**，是浏览器默认的布局方式，它规定了盒子在页面中的排列方式。总体规则是——块盒独占一行，行盒水平依次排列。

:::tip[包含块(Containing Block)]
每个盒子都有它的包含块，包含块决定了盒子的排列区域。**绝大部分情况下**，盒子的包含块，就是它父元素的内容盒。
:::

### 块盒

1. 每个块盒的总宽度（content + padding + border + margin）必须等于包含块宽度。

-   宽度的默认值是 auto，auto 就代表吸收剩余空间的能力。
-   magin 的默认值是 0，但可以设置为 auto。
-   width 和 margin 同时为 auto 时，**width 会优先获得 auto** ，margin 会优先获得 `0`。
-   若 content + padding + border + margin 的总宽度仍然不够，则 margin-right 会自动获得 auto，吸收剩余空间。
-   在常规流中，块盒可以通过 ` width 固定; margin-left: auto; margin-right: auto;` 实现水平居中。

2. 每个块盒垂直方向上的 auto 值。

-   height: auto 时，块盒的高度由内容决定。
-   margin: auto 时，块盒的垂直方向上的 auto 值会自动获得 0。

3. 百分比取值

-   padding 、margin 、width 的百分比取值，都是**相对于包含块**的**宽度**。
-   高度的百分比需要考虑**包含块的高度是否取决于子元素的高度**。
    -   如果父元素的高度取决于子元素的高度，比如父元素的高度是 auto 或者没有设置高度，那么子元素的高度百分比是无效的。
    -   如果父元素的高度不取决于子元素的高度，比如父元素的高度是固定的，那么子元素的高度百分比是有效的。

:::note
父元素的 width 是 600px，height 是 1000px。子元素的 margin-top 是 50%，那么子元素的 margin-top 的值是 300px，而不是 500px。
:::

4. 常规流里块盒的边距合并。

-   相邻垂直外边距会取最大值合并。
-   父子元素的垂直外边距合并

import { Tabs, TabItem } from "@astrojs/starlight/components";

<Tabs>
    <TabItem label="错误写法" icon="close">
        ```CSS
        .parent {
            height: 300px;
            margin-top: 30px;
        }
        .child {
            height: 100px;
            margin-top: 30px;
        }
        /*子元素紧贴着父元素父子元素的垂直外边距合并为30px*/

        ```
    </TabItem>
    <TabItem label="正确写法" icon="approve-check">
        ```CSS
        .parent {
            height: 300px;
            margin-top: 30px;
            padding-top: 30px;
        }
        .child {
            height: 100px;
            /* margin-top: 30px; */
        }
        ```
    </TabItem>

</Tabs>

## 浮动

---

### 应用场景

1. 文字环绕
2. 横向排列

### 基本特点

1. 修改 float 属性值为 left，元素向上向左浮动，修改为 right，元素向上向右浮动。
2. float 的默认值是 none，不浮动。
3. 浮动元素必定为块盒。
4. 浮动元素的包含块是父元素的内容盒。

### 盒子尺寸

1. 常规流 width 为 auto 时，吸收包含块剩余空间。浮动元素 width 为 auto 时，宽度由内容决定。
2. 浮动元素和常规流元素的高度都是由内容决定。
3. 常规流 margin 为 auto 时，在 width 吸收完空间之后，吸收剩余空间。浮动元素 margin 为 auto 时，会自动变为 0。
4. 边框、内边距、百分比设置，和常规流一样——都是相对于包含块的宽度。

### 盒子排列

1. 左浮动的盒子靠上靠左排列。
2. 右浮动的盒子靠上靠右排列。
3. 浮动盒子会避开常规流块盒。
4. 常规流块盒在排列时，会忽视浮动盒子。
5. 行盒在排列时，会避开浮动盒子。
6. 不会发生外边距合并。

> Q : 图片设置浮动达到的文字环绕效果，根据以上条件 p 元素是块盒，为什么里面的文字会环绕而不是被覆盖？

> A : 浏览器对于直接被块盒包裹的文字会生成一个行盒，该行盒叫**匿名行盒**。行盒会避开浮动盒子，所以文字会环绕浮动盒子。但是 p 元素的空间占据是不会被浮动盒子避开的，所以 p 元素空间会被浮动盒子覆盖。

### 高度坍塌

高度坍塌的根源：常规流盒子高度自动计算，不会考虑内部的浮动盒子。解决高度坍塌的方法：**清除浮动**。

clear 属性

-   默认值是 none，不清除浮动。
-   left，清除左浮动。该元素必须在左浮动元素的下方。
-   right，清除右浮动。该元素必须在右浮动元素的下方。
-   both，清除左右浮动。
-   inherit，继承父元素的 clear 属性值。

开发中，可以在浮动元素后面添加一个空元素，设置 clear 属性值为 both，清除浮动。

```CSS
/* Method 1 在浮动元素后面添加一个div并设置样式 */
.clearfix {
    clear: both;
}

/* Method 2 使用伪元素清除浮动 */
.clearfix::after {
    content: "";
    display: block;
    clear: both;
}
```
