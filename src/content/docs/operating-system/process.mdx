---
title: 谈一谈进程那点事
description: 进程
sidebar:
    order: 2
---

> _生活就像一个多任务进程，虽然总是有点 CPU 占用过高，但心情总能在调度中找到平衡，别让低优先级的烦恼卡住主线程~_

## 进程的概念

---

### 对进程的简单介绍

进程是操作系统进行资源分配和调度的基本单位，是程序在计算机上的一次执行过程。每个进程都有自己的独立内存空间，进程之间相互独立，互不影响。简单来说，操纵系统会执行程序、进程、任务或作业，进程就是执行中的程序。

:::tip
程序是被动的实体，而进程是活动的实体。当一个程序被载入内存时，这个程序就会变成进程。
:::

> Q : 进程在内存中的表现形式是什么？

> A : ![进程在内存中的表现形式](@src/assets/os/process-memory-structure.excalidraw.png)

### 进程控制块

每个进程在操作系统内用进程控制块 (Process Control Block, PCB) 来表示，PCB 是进程存在的唯一标志。PCB 包含了进程的描述信息和控制信息，如进程状态、进程优先级、进程调度信息、进程资源信息等。

> PCB 是进程在内存中的数据结构，又称任务控制块( Task Control Block, TCB )。

:::note
进程之间是树形结构
:::

### 进程的状态

进程在执行过程中，会经历不同的状态，主要包括以下几种：

1. **创建状态**：进程被创建，但还未进入就绪状态。
2. **就绪状态**：进程已经具备执行条件，等待 CPU 调度。
3. **执行状态**：进程正在 CPU 上执行。
4. **阻塞状态**：进程因等待某个事件（如 I/O 操作）而暂停执行。
5. **终止状态**：进程已经完成执行，等待被回收。

![进程状态](@src/assets/os/process-status.excalidraw.png)

## 进程的调度

---

### 进程调度队列

操作系统持有**就绪队列**和**一组设备队列**，进程可以在就绪队列中等待 CPU 调度，也可以在设备队列中等待 I/O 操作完成。

### 调度程序

调度程序可以分为**长期调度程序**、**中期调度程序**和**短期调度程序**。

1. **长期调度程序**：决定哪些进程进入就绪队列。
2. **中期调度程序**：将进程从内存中移出，以释放内存空间。
3. **短期调度程序**：决定哪个进程获得 CPU 资源。

![进程调度程序](@src/assets/os/process-scheduler-program.excalidraw.png)

### 上下文切换

将 CPU 切换到另一个进程需要保存当前进程的状态，并恢复另一个进程状态。

> 上下文切换依赖于硬件支持，如内存速度、寄存器数量、指令运行时间、载入/保存时间等。因此为了提高上下文切换速度，有的处理器提供了多种寄存器集合，上下文切换的时候只需要简单地改变当前寄存器组的指针。

:::note
上下文切换时间是额外的开销，因为上下文切换时系统不能做什么有用的工作。
:::

## 进程的操作

---

### 进程的创建

:::tip[还记得吗？]
系统中的进程结构是树形结构，也即是说进程和进程之间存在着父子关系，父进程可以创建子进程，子进程也可以创建子进程。
:::

进程的创建过程包括以下几个步骤：

1. **创建 PCB**：操作系统为进程创建一个 PCB，并初始化其状态。
2. **分配资源**：操作系统为进程分配所需的内存、CPU、I/O 等资源。
3. **加载程序**：将进程的程序代码和数据加载到内存中。
4. **设置进程状态**：将进程状态设置为就绪状态，并将其添加到就绪队列中。

> 进程创建的过程中，是存在创建选项的。比如资源共享选项、执行选项、地址空间选项。分别决定了子进程能拥有父进程的全部资源还是部分资源、父进程需要等待子进程的结束还是可以同时运行、子进程复制父进程内容还是覆盖父进程的内存空间。

### 进程的终止

进程的终止过程包括以下几个步骤：

1. **保存进程状态**：将进程的状态保存到 PCB 中。
2. **释放资源**：操作系统释放进程所占用的内存、CPU、I/O 等资源。
3. **删除 PCB**：操作系统删除进程的 PCB，将其从进程表中移除。

> 如果一个进程终止，其子进程也会随之终止，这种现象被称为**级联终止**。

> 如果一个进程结束，其子进程会变成**孤儿进程**，操作系统会将其父进程设置为 init 进程。

> 如果一个进程结束但是其父进程没有等待，那么这个进程的 PCB 就会变成**僵尸进程**，需要父进程调用 wait() 函数来回收。

## 进程间的通信

---

进程间的通信是操作系统提供的一种机制，用于进程之间交换数据和信息。进程间的通信方式主要包括以下几种：

1. **管道**：管道是一种半双工的通信方式，数据只能在一个方向上流动。管道分为匿名管道和命名管道。
2. **消息队列**：消息队列是一种全双工的通信方式，进程之间可以通过发送和接收消息来进行通信。
3. **共享内存**：共享内存是一种高效的通信方式，多个进程可以共享同一块内存空间，从而实现数据交换。

> 消息传递功能提供了发送消息和接收消息两种操作，其中消息可以是定长的或者变长的。而在消息通信之前必须建立通信线路，通信线路的逻辑实现方法从不同角度可以分为**直接或间接通信**、**同步或异步通信**、**自动或显式缓冲（通信缓冲）**。

1. 直接通信中，需要通信的每个进程必须明确地命名通信双方。而直接通信又分为**对称寻址**和**非对称寻址**，区别在于 receiver 是否要给 sender 命名。
2. 间接通信是通过 port 或 email 实现的。与直接通信的区别在于 ` 直接通信一个线路只对应一对进程，一对进程也只有一条线路；间接通信一个线路可以与多个进程相关联，一对进程也可以有多个线路。`
3. 无论是如何通信，消息都需要存储在缓冲区，也就是消息队列里。消息队列根据容量可以分为零容量、固定容量和无限容量。

> 共享内存的典型范例是生产者进程产生信息以供消费者进程消费的问题，即生产者和消费者问题。为了并发运行两个进程，必须存在一个缓冲区，也就是共享内存区域，生产者进程将信息放入缓冲区，消费者进程从缓冲区中取出信息。我们可以限制缓冲区是有限的还是无限的来控制生产者是否继续生产。

:::note
考虑到共享内存，为了实现必须要做到共享区域解除掉进程对内存地址的保护机制，并且需要保障数据的一致性，因此需要存在一个同步机制。
:::

:::tip
进程间的通信方式有很多种，不同的通信方式有不同的特点和适用场景。其中，消息传递适合传递较少数量的数据、需要内核的干涉、比较容易实现；共享内存允许以最快的速度进行方便的通信、不需要内核的干涉。
:::

## 客户机与服务器之间的通信

---

### RPC 与 RMI

**远程过程调用**（Remote Procedure Call，RPC）和**远程方法调用**（Remote Method Invocation，RMI）是两种常用的进程间通信方式。

远程过程调用抽象化了网络通信的细节，使得调用远程过程就像调用本地过程一样简单。每个独立的远程过程都有一个存根，作为其代理。当客户机调用位于远程主机上的过程时，客户端存根编组参数，并向服务器相应存根发送参数，服务器存根接收参数以后对参数进行解组并调用相应过程。

> 客户机与服务器之间端口的绑定需要预先通过集合点机制动态绑定。

:::tip
这两者的主要区别是被使用的方法或者规范。RMI 使用面向对象的规范，它需要知道对象和它需要调用的对象的方法。相反，RPC 不是面向对象也不处理对象。然而，它调用特定的已经建立的子程序。
:::

### 套接字

套接字（Socket）是一种网络通信协议，用于在网络上实现进程间的通信。套接字可以用于实现客户端和服务器之间的通信，也可以用于实现同一台机器上不同进程之间的通信。套接字可以分为**面向连接的套接字**和**无连接的套接字**。

## 管道

---

管道是一种进程间通信机制，用于在具有亲缘关系的进程之间传递数据。管道分为**匿名管道**和**命名管道**。

匿名管道是一种半双工的通信方式，数据只能在一个方向上流动。匿名管道只能用于具有亲缘关系的进程之间，如父子进程之间。

命名管道是一种全双工的通信方式，数据可以在两个方向上流动。命名管道可以在没有亲缘关系的进程之间使用，如不同进程之间。

> 管道可以是多输入管道，但也是基于队列实现的，虽然不能保证顺序，但依然遵守 FIFO。
