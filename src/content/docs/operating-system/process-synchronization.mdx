---
title: 进程同步
description: 进程同步
sidebar:
    order: 5
---

> _我和你之间需要同步，不然我总感觉自己是单向的异步调用。_

## 背景

---

在多进程环境中，进程间需要共享数据，而共享数据往往需要同步，否则会导致数据不一致。例如，多个进程同时访问一个共享变量，如果不进行同步，可能会导致数据不一致。因此，进程同步是操作系统中的一个重要概念。

## 临界区问题

---

临界区是指一个进程在访问共享资源时的一段代码，这段代码在执行过程中不允许被其他进程中断。临界区问题是指多个进程同时访问临界区，导致数据不一致的问题。解决竞争条件问题的关键是：**一次只有一个进程可以进入临界区**。

> 解决临界区问题需要满足的条件有**互斥**、**前进**、**有限等待**。

### Peterson 算法

Peterson 算法是一种解决临界区问题的算法，它通过设置两个标志变量和一个变量来控制进程的进入和退出临界区。具体实现如下：

```c
#define TRUE 1
#define FALSE 0

int turn; // 表示当前允许进入临界区的进程编号
int flag[2]; // 表示进程是否想要进入临界区

void enter_region(int process) {
    int other = 1 - process;
    flag[process] = TRUE;
    turn = process;
    while (turn == process && flag[other] == TRUE) {
        // 等待其他进程退出临界区
    }
}

void leave_region(int process) {
    flag[process] = FALSE;
}
```

> Q : 没有 turn 可以吗？

> A : 不可以，因为如果没有 turn，那么两个进程可能会同时进入临界区，导致数据不一致。turn 的作用是保证一次只有一个进程可以进入临界区。

## 硬件同步

---

> Q : 可不可以通过禁用中断的方式解决临界区问题？

> A : 理论可行，但代价较高。可以通过简单硬件指令来解决.

现代计算机系统提供了特殊指令：TestAndSet 和 CompareAndSwap，它们可以**原子性地**执行一系列操作，从而避免竞争条件。前者可以通用过声明全局变量 lock 来实现互斥，后者可以通过声明全局变量 lock 和局部变量 key 来实现互斥。

:::note
Peterson 算法会出现忙等待的问题。为此，引入有限等待原子指令，用布尔变量 waiting 来表示进程是否在等待进入临界区。
:::

## 信号量

---

信号量是用于进程同步的机制，通过一个整型变量表示资源的数量。具体实现如下：

```c
typedef struct {
    int value;
    struct process *list;
} semaphore;

void P(semaphore *s) {
    s->value--;
    if (s->value < 0) {
        // 将当前进程加入到等待队列中
    }
}

void V(semaphore *s) {
    s->value++;
    if (s->value <= 0) {
        // 从等待队列中唤醒一个进程
    }
}
```

> 信号量可以分为**计数信号量**和**二进制信号量**。二进制信号量是一种特殊的信号量，它的值只有 0 和 1。计数信号量是一种通用的信号量，它的值可以是任意整数。

:::tip
计数信号量可适用于**优先约束**例子。
:::

信号量的实现关键是保障 wait 和 signal 操作的原子性。在单处理器环境下可以采用禁止中断的方法，但是多处理环境下这种方法既困难又危险。

## 经典同步问题

---

### 有限缓冲问题

用信号量 empty 和 full 来表示缓冲区中空槽和满槽的数量，用 mutex 来表示对缓冲区的互斥访问。

### 读者-写者问题

用信号量 wrt 为读者和写者进程共享，变量 readCount 来跟踪当前正在读的进程数量，信号量 mutex 来保护 readCount。

### 哲学家就餐问题

用信号量来表示每个哲学家是否在吃饭，用互斥信号量来保护临界区。

## 管程

---

管程是一种高级同步机制，它将共享变量和同步操作封装在一个模块中，从而简化了进程同步的实现。具体实现如下：

```c
monitor monitor_name {
    int variable;
    condition condition_name;
    // ...
    procedure procedure_name() {
        // ...
    }
    // ...
}
```

> 管程的特点是**隐式互斥**和**条件变量**。隐式互斥是指管程中的共享变量和同步操作是自动互斥的，不需要显式地使用信号量。条件变量是一种特殊的变量，用于等待和唤醒进程。

> Q : 为什么要引入管程？

> A : 管程可以把分散在各进程中的临界区集中起来进行管理；防止进程有意或无意的违法同步操作；便于用高级语言来书写程序，也便于程序正确性验证。

管程的使用需要在对象或者模块中收集相关的共享数据并定义访问共享数据的方法。管程由**一个锁**、**0 或多个条件变量**和**一组过程**组成。管程的进入由一个入口队列控制，一个进程在进入管程之前必须先获得管程的锁，在进程退出管程时释放锁。
