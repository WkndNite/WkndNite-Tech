---
title: 内存管理
description: 内存管理
sidebar:
    order: 7
---

> _我的记忆是分块的，一页一页地翻，偶尔还会缺页。_

## 前置知识

---

### 进程的逻辑地址

```bash
$ cat maps
```

输出内容如下：

```bash
00400000-00401000 r-xp 00000000 08:01 4194305                            /bin/ls
00600000-00601000 r--p 00000000 08:01 4194305                            /bin/ls
00601000-00602000 rw-p 00001000 08:01 4194305                            /bin/ls
7f9e9a5b6000-7f9e9a5b8000 r-xp 00000000 08:01 4194305                    [vdso]
7f9e9a5b8000-7f9e9a5ba000 r--p 00000000 00:00 0                          [vvar]
7f9e9a5ba000-7f9e9a5bb000 r-xp 00000000 00:00 0                          [vsyscall]
7f9e9a5bb000-7f9e9a7c6000 r-xp 00000000 08:01 4194305                    [stack]
7f9e9a7c6000-7f9e9a9c5000 ---p 001e7000 08:01 4194305                    [heap]
```

分别表示：

1. 地址：库在进程里的地址范围。
2. 权限：rwxps。
3. 偏移量：库在磁盘上的偏移量。
4. 设备：设备号，包括主设备号和次设备号。
5. 节点号：映像文件的节点号。
6. 路径：映像文件的路径。

### 进程的物理地址

/proc/$pid/pagemap 可以查看每个虚拟页对应的物理页。

## 内存的编址方式

---

### 进程使用内存空间的界定

为了确保进程只访问合法的地址范围，一个进程使用的内存地址范围是由一对**基地址寄存器**和**界限地址寄存器**来定义的。

### 地址绑定

地址绑定是将虚拟地址和物理地址进行映射的过程。**逻辑地址**也叫相对地址，用户程序在经过编译后形成的目标代码，其首地址一般为 0，其余指令中的地址都是相对于首地址来编址。**物理地址**也叫内存地址或绝对地址，是内存单元的地址编号。

> **重定位**是目标程序载入内存时，对目标程序中的指令和数据地址修改的过程称为重定位。源程序中的地址经过编译称为可重定位地址，在经过链接程序或加载程序处理成为绝对地址。
> ![地址绑定](@src/assets/os/memory-redirect.excalidraw.png)

:::note
逻辑地址不能直接用来寻址，物理地址可以用来直接寻址。
:::

通常将指令和数据绑定到内存地址有以下三种情况：

1. 编译时：编译时就知道进程将在内存中的驻留地址。
2. 加载时：在编译时不知道进程驻留的内存地址，比那一起必须生成可重定位的代码。对于这种情况，最后绑定延迟到加载时才能执行。
3. 执行时：如果进程在执行时可以从一个内存段移动到另一个内存段，那么绑定必须延迟到执行时才进行。

> 内存管理单元（MMU）是映射逻辑地址为物理地址的硬件设备。

### 动态加载、动态链接、静态链接

**动态加载**：程序在运行时才加载到内存中，可以节省内存空间。优点在于内存使用率高，适合用户用大量代码来操作不常发生的事件，不需要操作系统特别支持。

**静态链接**：加载程序将库的内容合并到二进制程序镜像中，一直驻留在内存。

**动态链接**：存根用来定为适当的内存驻留库程序。加载程序将库的地址记录在二进制程序镜像中，运行时才加载库的内容到内存中，并更新二进制程序镜像中的地址。优点在于内存使用率高，适合用户用少量代码来操作大量事件，需要操作系统特别支持。

:::note
动态链接和动态加载都是需要的时候加载到内存，但是动态链接在程序启动的时候只有链接地址，需要的时候才会加载到内存，这是由操作系统决定的；动态加载是通过程序的方法来控制加载，这是由程序员决定的。
:::

### 交换

进程可以暂时从内存中交换到备份存储上(通常是快速磁盘)，当需要再次执行时再调回到内存。交换算法包括优先级算法、滚入滚出、换入换出。交换时间与交换内存空间量成正比。

## 内存分配方式

---

内存分配方式可以分为**连续分配**和**非连续分配**。非连续分配又称为离散分配，每个进程可以由多个不连续的内存区域组成。非连续分配又分为**分页**和**分段**。

### 连续分配

每个进程位于连续的内存区域，连续分配也可以分为**多分区分配**和**可变分区分配**。

其中，**多分区分配**每个分区大小可以不相同，根据程序大小分配当前空闲且大小合适的分区。而**可变分区方法**将整个内存空间视作一个孔，操作系统需要用表来记录当前已用和未用的内存。

> 首次适应：分配足够运行进程的第一个找到的孔。

> 最佳适应：分配足够运行进程的最小的孔。

> 最差适应：分配足够运行进程的最大的孔。

:::tip
以上方法会产生**碎片**。碎片根据位置在区内还是区外可以分为内部碎片和外部碎片。随之而出现一种解决办法：**紧缩**。意为移动内存内容，将所哟的空闲空间合并成一整块，但是需要注意，这只适用于动态重定位的时候，不适用于静态定位，而且开销较大。
:::

### 分页

#### 分页基础

把物理内存划分为固定大小的块，称为**帧**。把逻辑内存划分为固定大小的块，称为**页**。一个页对应一个帧，当需要分配内存时，以页为单位分配内存.若程序大小为 n 页，则需要有 n 个帧来存放，而这些帧是**不必连续的内存空间**。

> Q : 如何实现帧和页的对应呢？

> A : 逻辑地址分为两个部分：**页号**和**页内偏移量**。页号和页内偏移量通过**页表**来映射。页表是一个数组，每个元素对应一个页，记录了该页在物理内存中的位置。页号是页表的索引，相应页表中存储着该页所在物理内存的基地址。页偏移量结合基地址能形成物理地址。

> Q : 页表如何存储？

> A : 页表可以用一组**专用寄存器**来保存，也可以将页表放入到**内存**中。**如果存放到内存中需要页表基寄存器和页表长寄存器**。

:::tip
如果将页表存放在内存中，需要两次访问内存才能查询数据，需要多一次对页表的查询。因此，这导致了对数据访问的速度降低。解决办法是引入**硬件缓冲**，称之为**地址转换旁观缓冲**（Translation Lookaside Buffer，TLB）。
:::

> Q : 在分页环境下怎么实现内存的保护？

> A : 与每个帧关联一个**保护位**，建立与页表中的每一条目相关联的有效位或无效位，表示相关的页在进程的逻辑地址空间内是合法的还是非法的。

分页的优点是能够通过共享页实现代码共享：进程的代码可以分为可以共享的代码和不可共享的代码，对于可以共享的代码就可以通过共享页来实现。

> 可共享的代码，即可重入代码，每个进程共享代码段的（页）逻辑地址是相同的。不可共享的代码，即私有代码和数据，针对私有代码和数据的（页）逻辑地址是不同的。

#### 页表的实现

1. **层次页表**：将页表分为多个层次，每一层页表都包含下一层页表的页号。层次页表可以减少页表的大小，但是会增加页表的查询次数。.

2. **哈希页表**：哈希页表的每一个条目是一个链表，链表的元素包括虚拟页表、所映射的帧号和下一个元素指针。

3.**反向页表**：是为了减少页表消耗的内存空间而采用的方法，反向页表需要记录进程标识符、页码、页偏移量。

### 分段
