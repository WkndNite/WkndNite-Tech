---
title: CPU调度
description: CPU调度
sidebar:
    order: 4
---

> _我的个人项目就像被饿死的进程，永远得不到调度机会。所有资源都被工作和生活的高优先级进程抢占，等我想起它时，它早已"饿死"在内存角落里了。_

## 基本概念介绍

---

每当有进程需要使用 CPU 时，操作系统必须选择一个进程来执行。选择一个进程来执行的过程称为调度。调度程序是操作系统的一部分，负责决定哪个进程应该使用 CPU。

CPU 调度程序可以分为**抢占调度**和**非抢占调度**。

-   **抢占调度**：操作系统可以随时中断正在运行的进程，并将 CPU 分配给另一个进程。这种调度方式允许操作系统根据需要动态地调整进程的优先级，以优化系统性能。
-   **非抢占调度**：一旦进程开始执行，它将一直运行，直到它自己主动放弃 CPU。这种调度方式简单，但可能无法有效地利用 CPU 资源。

:::tip
**分派程序**是一个模块，用来将 CPU 分配给进程。其功能包括切换上下文、切换到模式、跳转到合适位置重启程序。分派程序停止一个进程而启动另一个进程要花的时间称为**分派延迟**。
:::

## 调度准则和调度算法

---

### 调度准则

不同的调度算法具有不同的属性，分析 CPU 调度算法需要考虑以下准则：

-   **CPU 利用率**：CPU 利用率是 CPU 忙于执行进程的时间与总时间之比。高 CPU 利用率意味着 CPU 在忙于执行进程，而低 CPU 利用率意味着 CPU 在等待进程。
-   **吞吐量**：吞吐量是单位时间内完成的进程数量。高吞吐量意味着系统在单位时间内可以处理更多的进程。
-   **响应时间**：响应时间是进程从提交到首次执行之间的时间。低响应时间意味着进程可以更快地开始执行。
-   **周转时间**：周转时间是进程从提交到完成之间的时间。低周转时间意味着进程可以更快地完成。
-   **等待时间**：等待时间是进程在就绪队列中等待 CPU 的时间。低等待时间意味着进程可以更快地开始执行。

### 调度算法

#### 先来先服务（FCFS）

先来先服务（First Come First Served，FCFS）调度算法是一种简单的调度算法，它按照进程到达的顺序来执行进程。这种算法的优点是实现简单，但缺点是可能导致进程的等待时间过长，特别是当有短进程和长进程混合时。

![FCFS](@src/assets/os/scheduler-FCFS.excalidraw.png)

#### 最短作业优先（SJF）

最短作业优先（Shortest Job First，SJF）调度算法是一种调度算法，它按照进程的执行时间来选择进程。这种算法的优点是可以最小化平均等待时间，但缺点是可能导致长进程饥饿，即长时间得不到执行机会。

![SJF](@src/assets/os/scheduler-SJF.excalidraw.png)

:::tip
对于给定的一组进程，在平均等待时间上，最短作业优先调度算法是最优算法。
:::

#### 最短剩余时间优先（SRTF）

最短剩余时间优先（Shortest Remaining Time First，SRTF）调度算法是一种抢占式调度算法，它按照进程的剩余执行时间来选择进程。这种算法的优点是可以最小化平均等待时间，并且可以有效地处理短进程和长进程混合的情况。

#### 优先级调度（Priority Scheduling）

优先级调度是一种调度算法，它根据进程的优先级来选择进程。这种算法的优点是可以根据进程的重要性来调整进程的优先级，从而优化系统性能。但缺点是可能导致低优先级进程饥饿，即长时间得不到执行机会。

![SJF](@src/assets/os/scheduler-Priority.excalidraw.png)

:::note
优待老人策略是在这个周期内提高了优先级，当进程再次来到时，优先级仍然是原来的值。
:::

#### 循环轮转（Round Robin）

循环轮转（Round Robin，RR）调度算法是一种抢占式调度算法，它按照进程到达的顺序来执行进程，但每个进程只能执行一定的时间片。这种算法的优点是可以最小化平均等待时间，并且可以有效地处理短进程和长进程混合的情况。但缺点是可能导致长进程饥饿，即长时间得不到执行机会。

![SJF](@src/assets/os/scheduler-RR.excalidraw.png)

> 周转时间比最短作业优先调度长，但响应时间短。

> Q : 周转时间依赖于时间片的大小。时间片长度太大会导致 RR 与 FCFS 一样，太小又会导致上下文切换负载太重。那么，如何确定合适的时间片长度？

> A : 时间片长度一般取为 10-100 毫秒。可以通过 tradeoff 来确定。如果上下文切换时间约为时间片长度的 10%，则大约 10%的 CPU 时间会用于上下文切换，这是可以接受的。通常，如果绝大多数进程能在一个时间片内完成，那么平均周转时间会改善。

#### 多级队列（Multilevel Queue）

多级队列（Multilevel Queue，MLQ）调度算法是一种多级队列调度算法，它将就绪队列分为多个队列，每个队列有不同的优先级。

#### 多级反馈队列（Multilevel Feedback Queue）

多级反馈队列（Multilevel Feedback Queue，MLFQ）调度算法是一种多级队列调度算法，它将进程分为多个队列，每个队列有不同的优先级。这种算法的优点是可以根据进程的特性来调整进程的优先级，从而优化系统性能。但缺点是可能导致低优先级进程饥饿，即长时间得不到执行机会。

> 调度程序需要确定的参数有：队列数量、每个队列的调度算法、确定何时升级到更高优先级队列的方法、确定何时降级到更低优先级队列的方法、确定进程在需要服务的时候应该进入哪个队列的方法。

## 多处理器调度

---

处理器可以分为**同构**和**异构**两种。从对称性角度，又可以分为**对称多处理器（SMP）**和**非对称多处理器（NUMA）**。对称多处理器中的每个处理器都有自己的调度算法，不允许处理器之间的移动。而非对称多处理器中的处理器可以移动，但是只有一个处理器用于调度任务。

处理器的亲和性可以分为：**硬亲和性**（hard affinity）和**软亲和性**（soft affinity）。硬亲和性是指进程只能在指定的处理器上运行，而软亲和性是指进程可以在任何处理器上运行，但是调度程序会尽量将进程调度到指定的处理器上。

**负载平衡**（load balancing）是指将任务分配到多个处理器上，以平衡各个处理器的负载。负载平衡通常可以分为 push migration 和 pull migration 两种方式。前者是指定期地检查各个处理器的负载，如果发现某个处理器的负载过高，就将任务从该处理器移动到其他处理器上；后者是指空闲的处理器主动从负载高的处理器上拉取任务。

## 线程调度

---

线程的竞争范围有两种，分别是**全局竞争范围**和**局部竞争范围**。全局竞争范围是指所有线程都可以竞争所有处理器，而局部竞争范围是指只有同一进程中的线程可以竞争同一处理器。其中，全局竞争范围也叫系统竞争范围（System Contention Scope, SCS），局部竞争范围也叫进程竞争范围（Process Contention Scope, PCS）。

## 实时调度

---

实时系统中的进程具有截至时间要求，进程必须在截至时间之前完成。实时调度算法需要考虑进程的截至时间，以避免进程超时。实时系统可以分为**硬实时**和**软实时**两种。而实时调度任务可以分为**周期性任务**、**非周期性任务**和**零星任务**。实时调度算法可以分为**Rate Monotonic**、**Earliest Deadline First**和**Earliest Deadline Zero Laxity**三种。
