---
title: 进程 or 线程？傻傻分不清楚！
description: 线程
sidebar:
    order: 3
---

> _人生像是一个多线程程序，操作系统有时分配资源不均，工作线程满载，快乐线程死锁，但也要记得偶尔给自己来个意外的 breakpoint。_

## 线程概述

---

线程（Thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

### 线程与进程的区别

1. **资源占用**：线程是进程内的一个执行单元，因此线程比进程更轻量级，占用资源更少。进程拥有独立的内存空间和系统资源，而线程共享进程的内存空间和系统资源。所以，线程的运行时进程内部的执行轨迹，是进程内部执行指令的跟踪。
2. **调度**：线程的调度由操作系统负责，而进程的调度由操作系统和应用程序共同负责。线程的调度通常比进程的调度更频繁，因为线程的创建和销毁比进程的创建和销毁更简单。线程的创建只需要复制栈和寄存器的内容，但是进程的创建还涉及到了上下文的切换、PCB 以及数据的交换等。
3. **独立性**：线程是进程内的一个执行单元，因此线程之间可以共享进程的资源，如内存、文件等。而进程之间是相互独立的，它们之间不能直接共享资源。

### 多线程编程的优点

1. **提高程序性能**：多线程编程可以提高程序的并发性能，使得程序可以同时执行多个任务，从而提高程序的运行效率。
2. **提高资源利用率**：多线程编程可以提高对系统资源的利用率，因为线程之间可以共享进程的资源，从而减少资源的浪费。
3. **简化程序设计**：多线程编程可以简化程序的设计，因为线程之间的通信和同步比进程之间的通信和同步更简单。

## 多线程模型

---

操作系统的服务和线程之间的关系模型可以分为 `一对一模型`、`多对一模型` 、 `多对多模型` 和 `二级模型`。

:::tip[用户线程与内核线程]
**用户线程**受内核的支持，但是由用户层的线程库来管理，并不需要内核的管理。**内核线程**由内核来管理、维护和调度。

用户线程和内核线程之间必然会才能在一种关系，可能是一对一关系，也可能是一对多关系，或者是多对多关系。建立起来的这种关系，我们称之为**映射**。
:::

### 一对一模型

一对一模型中，每个用户线程都对应一个内核线程。这种模型下，用户线程的创建、销毁、同步等操作都需要内核的支持，因此效率较低。但是，这种模型下，用户线程的调度是由内核来完成的，因此可以充分利用多核处理器的优势。也就是说一对一模型 `可以提供并发功能，当一个线程在执行阻塞系统调用时，可以调度另一个线程继续执行` 。

### 多对一模型和多对多模型

多对一模型和多对多模型中，多个用户线程对应一个内核线程。这种模型下，用户线程的创建、销毁、同步等操作不需要内核的支持，因此效率较高。但是，这种模型下，用户线程的调度是由用户层的线程库来完成的。

:::note
一对一模型唯一缺点是内核负担重，多对一模型的缺点是无法提供并发模型。多对多模型没有以上缺点，但是需要提供调度机制，实现起来比较复杂。
:::

### 二级模型（混合模型）

是多对多模型的变种，允许用户线程绑定一个特定的内核线程。

## 线程库

---

线程库是为程序员提供的用来创建和管理线程的 API，主要有**非嵌入到内核的方式**和**嵌入到内核的方式**。而目前主要使用的三种线程库有**POSIX Pthread**、**Windows32 Thread**和**Java Thread**。

## 多线程程序相关问题

---

### 系统调用 fork() 和 exec()语义

> Q1 : 如果进程中的某一个线程调用 fork()，那么新进程会复制所有线程呢，还是只复制调用 fork()的线程呢？

> A1 : 有的 Unix 系统提供两种形式的 fork()系统调用，开发者可以决定只复制一个或者复制全部。

> Q2 : 那么，什么时候复制全部，什么时候复制一个好呢？

> A2 : 这取决于创建新进程的目的。请考虑 exec()系统调用的语义，exec()语义是用参数所指定的程序替换整个进程。如果调用 exec()，就复制一个线程，否则，复制全部线程。

### 线程的取消

**目标线程**：线程完成任务之前终止线程的任务，需要取消的线程一般称为目标线程。

**取消点**：当一个线程认定为可以安全取消时，可以安全取消的这个点被称为取消点。

目标线程的取消可能发生 `要取消的线程正在更新与其他线程共享的数据`，为此，提供**异步取消**和**延迟取消**。

> 线程取消请求的实际取消行为依赖于线程的状态，线程取消的模式分为**Off Mode**、**Deferred Mode**和**Asynchronous Mode**。

### 信号处理

**信号**是用来通知进程某个特定事件的发生，这需要操作系统提供一种内核和进程之间的通信机制。信号可以分为**异步信号**和**同步信号**。

**信号处理程序**是用来处理发生的事件，处理过程分为由特定事件产生信号、信号传送给进程、信号处理程序处理相应程序。而信号处理程序分为**默认信号处理程序**和**用户定义的信号处理程序**。

:::note[信号传递给具体哪个线程？]
发送信号的方法依赖于产生信号的类型。CTRL+C 产生的信号必须发送给进程内的每个
线程。Pthread 提供的 pthread_kill(pthread_t tid, int signal) 函数就可以把信号传送给指定的线程。
:::

### 线程池

**线程池的主要思想**是在进程开始时创建一定数量的线程，并放入到进程池中等待工作，目的就是提高效率。主要优点是通常用现有线程处理请求要比等待创建新的线程要快，同时线程池限制了在任何时候可用线程的数量，以防止大量创建并发线程，有助于管理。

### 调度程序的激活

多对多模型和二层模型中的用户线程和内核线程需要通信，以便维护内核线程的适当数量。

> 用户和内核线程之间设置一种中间数据结构，这种数据结构通常称为**轻量级进程（LWP：Light Weight Process）**。

> 对于用户线程库，LWP 表现为一种应用程序可以调度用户线程的虚拟处理器。

> 每个 LWP 与内核线程相连，该内核线程被操作系统调度到物理处理器上运行。

> 如果内核线程阻塞，LWP 也阻塞，相用户线程也会阻塞。

**调度程序的激活**是一种解决用户线程库和内核之间通信的方法，提供的这种通信机制称为**UPCALL**。UPCALL 由具有 UPCALL 处理句柄的线程库处理，而且 UPCALL 处理句柄必须在虚拟处理器上运行。
